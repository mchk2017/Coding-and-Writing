# **Java Foundations (Second Edition)**
## John Lewis, Peter DePasquale & Joseph Chase
---
###TABLE OF CONTENT###
---
```html
CHAPTER 1 INTRODUCTION
```
[Chapter 1](./Chapter 1.md) introduces the Java programming language and the
basics of program development. It contains an introduction to object-oriented
development, including an overview of concepts and terminology. This chapter
contains broad introductory material that can be covered while students become
familiar with their development environment.

* Chapter Objectives
  * Introduce the Java programming language.
  * Describe the steps involved in program compilation
and execution.
  * Explore the issues related to problem solving in general.
  * Discuss the activities involved in the software development
process.
  * Present an overview of object-oriented principles.

This book is about writing well-designed software. We
begin by examining a very basic Java program and using it
to explore some initial programming concepts. We then lay
the groundwork for software development on a larger scale,
exploring the foundations of problem solving, the activities
involved in software development, and the principles of
object-oriented programming.

```html
CHAPTER 2 DATA AND EXPRESSIONS
```
[Chapter 2](./Chapter 2.md) explores some of the basic types of data used
in a Java program and the use of expressions to perform calculations. It discusses
the conversion of data from one type to another, and how to read input interac-
tively from the user with the help of the Scanner class.

* Chapter Objectives
  * Discuss the use of character strings, concatenation,
and escape sequences.
  * Explore the declaration and use of variables.
  * Describe the Java primitive data types.
  * Discuss the syntax and processing of expressions.
  * Define the types of data conversions and the mechanisms
for accomplishing them.
  * Introduce the Scanner class to create interactive programs.

This chapter explores some of the basic types of data
used in a Java program and the use of expressions to per-
form calculations. It discusses the conversion of data from
one type to another, and how to read input interactively
from the user running a program.

```html
CHAPTER 3 USING CLASSES AND OBJECTS
```
[Chapter 3](./Chapter 3.md) explores the use of predefined classes
and the objects that can be created from them. Classes and objects are used to
manipulate character strings, produce random numbers, perform complex calcu-
lations, and format output. Packages, enumerated types, and wrapper classes are
also discussed.

* Chapter Objectives
  * Discuss the creation of objects and the use of object reference
variables.
  * Explore the services provided by the String class.
  * Describe how the Java standard class library is organized
into packages.
  * Explore the services provided by the Random and Math classes.
  * Discuss ways to format output using the NumberFormat and
DecimalFormat classes.
  * Introduce enumerated types.  
  * Discuss wrapper classes and the concept of autoboxing.
  
This chapter further explores the use of predefined
classes and the objects we can create from them. Using
classes and objects for the services they provide is a funda-
mental part of object-oriented software, and sets the stage
for writing classes of our own. In this chapter, we use
classes and objects to manipulate character strings, pro-
duce random numbers, perform complex calculations, and
format output. This chapter also introduces the concept of
an enumerated type, which is a special kind of class in
Java, and discusses the concept of a wrapper class.

```html
CHAPTER 4 CONDITIONALS AND LOOPS
```
[Chapter 4](./Chapter 4.md) covers the use of boolean expressions to
make decisions. All related statements for conditionals and loops are discussed,
including the enhanced version of the for loop. The Scanner class is revisited
for iterative input parsing and reading text files.

* Chapter Objectives
  * Discuss the flow of control through a method.
  * Explore boolean expressions that can be used to make
decisions.
  * Perform basic decision making using if and switch
statements.
  * Discuss issues pertaining to the comparison of certain
types of data.
  * Execute statements repetitively using while , do ,
and for loops.
  * Discuss the concept of an iterator object and use one
to read a text file.

All programming languages have statements that allow
you to make decisions to determine what to do next. Some
of those statements allow you to repeat a certain activity
multiple times. This chapter discusses several such state-
ments, as well as exploring some issues related to comparing
data and objects. We begin with a discussion of boolean
expressions, which form the basis of any decision.

```html
CHAPTER 5 WRITING CLASSES
```
[Chapter 5](./Chapter 5.md) explores the basic issues related to writing classes
and methods. Topics include instance data, visibility, scope, method parameters,
and return types. Constructors, method design, static data, and method overload-
ing are covered as well. Testing and debugging are now covered in this chapter as
well.

* Chapter Objectives
  * Explore techniques for identifying the classes and objects
needed in a program.
  * Discuss the structure and content of a class definition.
  * Establish the concept of object state using instance data.
  * Describe the effect of visibility modifiers on methods and data.
  * Explore the structure of a method definition, including
parameters and return values.
  * Discuss the structure and purpose of a constructor.
  * Discuss the relationships among classes.
  * Describe the effect of the static modifier on methods and data.
  * Discuss issues related to the design of methods, including
method decomposition and method overloading.

In previous chapters we used classes and objects for the
various services they provide. We also explored several fun-
damental programming statements. With that experience as
a foundation, we are now ready to design more complex
software by creating our own classes, which is the heart of
object-oriented programming. This chapter explores the ba-
sics of class definitions, including the structure of methods
and the scope and encapsulation of data. It also examines the
creation of static class members and overloaded methods.

```html
CHAPTER 6 GRAPHICAL USER INTERFACES
```
[Chapter 6](./Chapter 6.md) is a thorough exploration of Java GUI
processing, focusing on components, events, and listeners. Many types of compo-
nents and events are discussed using numerous GUI examples. Additionally, lay-
out mangers, containment hierarchies, borders, tooltips, and mnemonics are
introduced.

* Chapter Objectives
  * Discuss the core elements needed in any Java GUI:
components, events, and listeners.
  * Explore the use of containers to organize components.
  * Explore various types of components, including buttons,
text fields, sliders, and combo boxes.
  * Discuss the various types of events that components generate,
and under what conditions.
  * Discuss the concept of a layout manager and explore several
specific ones.
  * Explore various types of mouse and keyboard events.
  * Discuss dialog boxes, including specialized dialog boxes
for choosing files and colors.
  * Explore the use of borders, tool tips, and mnemonics.

Many programs provide a graphical user interface
(GUI) through which a user interacts with the program.
As the name implies, a GUI makes use of graphical screen
components such as windows, buttons, check boxes, menus,
and text fields. GUIs often provide a more natural and rich
experience for the user compared to a simple text-based,
command-line environment. This chapter explores the
various issues related to developing a GUI in Java.

```html
CHAPTER 7 ARRAYS
```
[Chapter 7](./Chapter 7.md) contains extensive coverage of arrays and array processing.
Topics include bounds checking, initializer lists, command-line arguments, variable-
length parameter lists, and multidimensional arrays.

* Chapter Objectives
  * Define and use arrays for basic data organization.
  * Discuss bounds checking and techniques for managing
capacity.
  * Discuss the issues related to arrays as objects and arrays
of objects.
  * Explore the use of command-line arguments.
  * Describe the syntax and use of variable-length parameter lists.
  * Discuss the creation and use of multidimensional arrays.

When designing programs, we often want to organize
objects or primitive data in a form that is easy to access and
modify. This chapter introduces arrays, which are program-
ming constructs that group data into lists. Arrays are a fun-
damental component of most high-level languages, and a
useful tool in creating problem solutions.

```html
CHAPTER 8 INHERITANCE
```
[Chapter 8](./Chapter 8.md) covers class derivations and associated concepts such
as class hierarchies, overriding, and visibility. Strong emphasis is put on the proper
use of inheritance and its role in software design.

* Chapter Objectives
  * Explore the derivation of new classes from existing ones.
  * Define the concept and purpose of method overriding.
  * Discuss the design of class hierarchies.
  * Examine the purpose and use of abstract classes.
  * Discuss the issue of visibility as it relates to inheritance.
  * Discuss object-oriented design in the context of inheritance.

This chapter explains inheritance, a fundamental tech-
nique for organizing and creating classes. It is a simple but
powerful idea that influences the way we design object-
oriented software and enhances our ability to reuse classes
in other situations and programs. In this chapter we explore
the technique for creating subclasses and class hierarchies,
and we discuss a technique for overriding the definition of
an inherited method. We examine the protected modifier
and discuss the effect all visibility modifiers have on inher-
ited attributes and methods.

```html
CHAPTER 9 POLYMORPHISM
```
[Chapter 9](./Chapter 9.md) explores the concept of binding and how it relates
to polymorphism. Then we examine how polymorphic references can be accom-
plished using either inheritance or interfaces. Design issues related to polymor-
phism are examined as well.

* Chapter Objectives
  * Define polymorphism and explore its benefits.
  * Discuss the concept of dynamic binding.
  * Use inheritance to create polymorphic references.
  * Explore the purpose and syntax of Java interfaces.
  * Use interfaces to create polymorphic references.
  * Discuss object-oriented design in the context
of polymorphism.

This chapter discusses polymorphism, another funda-
mental principle of object-oriented software. We first ex-
plore the concept of binding and discuss how it relates to
polymorphism. Then we look at two distinct ways to im-
plement a polymorphic reference in Java: inheritance and
interfaces. Java interfaces are explored in general, estab-
lishing the similarities between them and abstract classes,
and bringing the polymorphism discussion full circle. The
chapter concludes with a discussion of the design issues
related to polymorphism.

```html
CHAPTER 10 EXCEPTIONS
```
[Chapter 10](./Chapter 10.md) covers exception handling and the effects of
uncaught exceptions. The try-catch statement is examined, as well as a dis-
cussion of exception propagation. The chapter also explores the use of excep-
tions when dealing with input and output, and examines an example that writes
a text file.

* Chapter Objectives
  * Discuss the purpose of exceptions.
  * Examine exception messages and the call stack trace.
  * Examine the try-catch statement for handling exceptions.
  * Explore the concept of exception propagation.
  * Describe the exception class hierarchy in the Java standard
class library.
  * Explore I/O exceptions and the ability to write text files.

Exception handling is an important part of an object-
oriented software system. Exceptions represent problems or
unusual situations that may occur in a program. Java pro-
vides various ways to handle exceptions when they occur.
We explore the class hierarchy from the Java standard li-
brary used to define exceptions, as well as the ability to de-
fine our own exception objects. This chapter also discusses
the use of exceptions when dealing with input and output,
and presents an example that writes a text file.

```html
CHAPTER 11 RECURSION
```
[Chapter 11](./Chapter 11.md) covers the concept, implementation, and proper use of
recursion. Several examples are used to elaborate on the discussion, including a
maze traversal and the classic Towers of Hanoi problem.

* Chapter Objectives
  * Explain the underlying concepts of recursion.
  * Explore examples that promote recursive thinking.
  * Define infinite recursion and discuss ways to avoid it.
  * Explain when recursion should and should not be used.
  * Examine recursive methods and unravel their processing steps.
  * Demonstrate the use of recursion to solve problems.

Recursion is a powerful programming technique that
provides elegant solutions to certain problems. This chapter
provides an introduction to recursive processing. It contains
an explanation of the basic concepts underlying recursion
and then explores the use of recursion in programming.

```html
CHAPTER 12 ANALYSIS OF ALGORITHMS
```
[Chapter 12](./Chapter 12.md) discusses the techniques for analyzing the
complexity of algorithms, including recursive algorithms. Big Oh notation is
introduced.

* Chapter Objectives
  * Discuss the goals of software development with respect
to efficiency.
  * Introduce the concept of algorithm analysis.
  * Explore the concept of asymptotic complexity.
  * Compare various growth functions.

As our programs become more sophisticated, it is impor-
tant to understand the concepts surrounding the efficiency
of our algorithms. There are usually multiple ways a partic-
ular task can be accomplished, and a more efficient solution
is generally preferred. As we explore topics such as sorting
and data structures in later chapters, the ability to analyze
the efficiency of our implementations becomes crucial.

```html
CHAPTER 13 SEARCHING AND SORTING
```
[Chapter 13](./Chapter 13.md) explores the linear and binary searching
algorithms, as well as five sorting algorithms. The sorts include both quadratic
and O(N log N) algorithms. The efficiency of these algorithms is examined.

* Chapter Objectives
  * Examine the linear and binary search algorithms.
  * Examine the selection, insertion, bubble, quick, and merge sort
algorithms.
  * Discuss the complexity of the search and sort algorithms.

Two common tasks in the world of software development
are searching for a particular element within a group and
sorting a group of elements into a particular order. There
are a variety of algorithms that can be used to accomplish
these tasks, and the differences between them are worth ex-
ploring carefully.

```html
CHAPTER 14 STACKS
```
[Chapter 14](./Chapter 14.md) introduces the concept of a collection and establishes the
importance of separating the interface from the implementation. Stacks are used
as the initial example of a collection, and both dynamic and fixed implementa-
tions of a stack are explored. Generic types are introduced in this chapter, detail-
ing their use in supporting the collection classes.

* Chapter Objectives
  * Define the concepts and terminology related to collections.
  * Explore the basic structure of the Java Collections API.
  * Discuss the abstract design of collections.
  * Explore issues surrounding collections including inheritance,
polymorphism, generics, and interfaces.
  * Define a stack collection.
  * Use a stack collection to solve a problem.
  * Examine an array implementation of a stack.
  * Describe the use of references to create linked structures.
  * Compare linked structures to array-based structures.
  * Explore the techniques for managing a linked list.
  * Discuss the need for a separate node object to form linked
structures.
  * Implement a stack collection using a linked list.

This chapter begins our exploration of collections and the
underlying data structures used to implement them. It lays
the groundwork for the study of collections by carefully
defining the issues and goals related to their design. In
particular, this chapter introduces a collection called a stack
and uses it to exemplify the issues related to the design, im-
plementation, and use of collections.

```html
CHAPTER 15 QUEUES
```
[Chapter 15](./Chapter 15.md) introduces FIFO queues and discusses options for their
implementation. As with stacks, a queue is explored first conceptually, then as
tools to help us solve problems, and finally by examining their underlying data
structures. Both array-based and dynamic link implementations are discussed.

* Chapter Objectives
  * Examine queue processing.
  * Define a queue abstract data type.
  * Demonstrate how a queue can be used to solve problems.
  * Examine various queue implementations.
  * Compare queue implementations.

A queue is another collection with which we are inher-
ently familiar. A queue is a waiting line, such as the line of
customers waiting in a bank for their opportunity to talk to
a teller. In fact, in many countries the word queue is used
habitually in this way. In such countries, a person might say
“join the queue” rather than “get in line.” Other examples
of queues include the check-out line at the grocery store or
cars waiting at a stoplight. In any queue, an item enters on
one end and leaves from the other. Queues have a variety of
uses in computer algorithms.

```html
CHAPTER 16 TREES
```
[Chapter 16](./Chapter 16.md) introduces the terms and concepts behind trees. Various
implementation strategies are discussed, and a recursive, linked approach is exam-
ined in detail. An example of a binary decision tree is explored as well.

* Chapter Objectives
  * Define the terms associated with trees.
  * Discuss possible strategies for implementing trees.
  * Discuss the various ways trees can be traversed.
  * Explore an implementation of a binary tree.
  * Use binary trees to represent decision trees.

This chapter begins our exploration of nonlinear
collections, and trees in particular. Trees are used in many
situations in computing. In this chapter we discuss the use
and implementation of trees, define the terms associated
with trees, analyze possible tree implementations, and look
at examples of implementing and using trees. Based on this
core material, Chapter 17 continues the exploration
of trees.

```html
CHAPTER 17 BINARY SEARCH TREES
```
[Chapter 17](./Chapter 17.md) covers the concept of search trees and a
linked implementation for a classic binary search tree. Tree rotation algorithms
are also discussed.

* Chapter Objectives
  * Discuss the nature of a binary search tree.
  * Explore a linked implementation of a binary search tree.
  * Discuss the generic version of the Comparable interface.
  * Discuss binary search tree rotations.

Search trees, especially binary search trees, and heaps are
among the most useful software structures. In this chapter,
we first explore the concept of a binary search tree and its
implementation. We examine algorithms for adding and
removing elements from binary search trees and for main-
taining balanced trees.

```html
CHAPTER 18 HEAPS AND PRIORITY QUEUES
```
[Chapter 18](./Chapter 18.md) discusses the concept of a heap and
its relationship to trees. A full linked implementation of a heap is explored.
Priority queues are used as an example of a collection in its own right, and the
natural relationship between heaps and priority queues are explored.

* Chapter Objectives
  * Define a heap and discuss its particular usefulness.
  * Discuss a linked implementation of a heap.
  * Discuss a heap sort.
  * Define a priority queue and its relationship to heaps.

We’ve evolved our discussion of trees throughout the
last several chapters. Chapter 16 explored general concepts
related to trees, and binary trees in particular. Chapter 17
extended the use of binary trees to create binary search
trees, which added a relationship characteristic among the
element stored in the tree. In this chapter we explore heaps,
another extension of binary trees, and their implementation.
Heaps are classic data structures, and are often used to im-
plement priority queues.

```html
CHAPTER 19 GRAPHS
```
[Chapter 19](./Chapter 19.md) discusses both directed and undirected graphs.
Additionally, weighted graphs are explored, and the differences between breadth-
first and depth-first graph traversals are covered. Minimal spanning trees are
introduced, and implementation strategies are discussed.

* Chapter Objectives
  * Discuss directed and undirected graphs.
  * Define weighted graphs and explore their use.
  * Define breadth-first and depth-first traversals of a graph.
  * Define a minimum spanning tree.
  * Discuss strategies for implementing graphs.

We’ve seen that trees, as discussed in Chapters 16 and
17, are nonlinear structures with a single root node. This
chapter introduces graphs, nonlinear structures in which
nodes may be connected to many other nodes, with no par-
ticular parent/child relationships. The exploration of graphs
and graph theory is an entire subdiscipline of both mathe-
matics and computer science. In this chapter we introduce
the basic concepts of graphs and their implementation.

```html
CHAPTER 20 HASHING
```
[Chapter 20](./Chapter 20.md) covers the concept of creating a hash table to facilitate
storage and retrieval of objects. Various classes that relate to hashing from the
Java API are explored.

* Chapter Objectives
  * Define hashing.
  * Examine various hashing functions.
  * Examine the problem of collisions in hash tables.
  * Explore the Java Collections API implementations of hashing.

In Chapter 17, we discussed the idea that a binary search
tree is, in effect, an efficient implementation of a set or a
map. In this chapter, we examine hashing, an approach to
implementing a set or map collection that can be even more
efficient than binary search trees.

```html
CHAPTER 21 DATABASES
```
[Chapter 21](./Chapter 21.md) explores the concept of databases and their manage-
ment, and discusses the basics of SQL queries. It then explores the techniques for
establishing a connection between a Java program and a database, and the API
used to interact with it.

* Chapter Objectives
  * Understand the basic concept of a database as it relates
to data storage.
  * Explain the concepts behind of relational databases.
  * Introduce how Java programs can connect to databases for the
purposes of creating, reading, updating and deleting data.
  * Briefly introduce the syntax of several different types of SQL
statements.

This chapter provides an introduction to databases and
interacting with databases using Java. A database is a large
repository of data organized for efficient storage and
searching. Discussing databases and the way we interact
with them through a Java program is a natural extension
of the concept of collections that have been a major theme
throughout this book.
